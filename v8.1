import time
import difflib
import cv2
import requests
import speech_recognition as sr
from gtts import gTTS, gTTSError
import os
import openai
import base64
from playsound import playsound

# === CONFIG ===
openai.api_key = (
    "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"
)  # Replace with your key

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# GLOBALS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
current_input_lang = None
current_tts_lang = None

exit_cmd = capture_cmd = translate_cmd = read_cmd = chat_cmd = moneycounter_cmd = ""
prompt_capture = prompt_translate = prompt_read = prompt_moneycounter = ""
chat_system_prompt = ""

feedback_capture_start = feedback_capture_success = ""
error_capture = error_connection = error_understand = ""
entering_chat = exiting_chat = exiting_program = unknown_command = ""

# Baseâ€‘64 copy of the most recently captured image (for followâ€‘ups)
last_image_b64 = None

# Create a persistent Recognizer instance to preserve calibration between listens.
recognizer = sr.Recognizer()
# Optionally, preâ€set the dynamic energy threshold and any other parameters
recognizer.dynamic_energy_threshold = True

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# AUDIO HELPERS
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def speak(text, lang=current_tts_lang, max_retries=3, initial_delay=1.0):
    if not text:
        return

    delay = initial_delay
    for attempt in range(1, max_retries + 1):
        try:
            # Generate and play speech
            tts = gTTS(text, lang=lang)
            tts.save("response.mp3")
            playsound("response.mp3")
            os.remove("response.mp3")
            return  # Success on first try.
        except (gTTSError, requests.exceptions.ConnectionError) as e:
            print(f"Attempt {attempt} failed: {e}")
            if attempt == max_retries:
                print("All TTS retries failed. Skipping audio output.")
                return
            print(f"Retrying in {delay} seconds...")
            time.sleep(delay)
            delay *= 2

# Modified: Increased ambient noise calibration duration and re-use of persistent recognizer.
def listen_for_command(suppress=False):
    global recognizer
    attempts = 0
    # Localized reâ€‘prompt messages for commands.
    repeat_command = {
        "en": "Please repeat your command.",
        "ar": "ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø£Ù…Ø±.",
        "fr": "Veuillez rÃ©pÃ©ter votre commande."
    }
    while attempts < 3:
        with sr.Microphone() as source:
            print("ğŸ™ï¸ Listening for command...")
            # Increase calibration duration for better ambient noise estimate.
            recognizer.adjust_for_ambient_noise(source, duration=1)
            recognizer.pause_threshold = 0.8
            audio = recognizer.listen(source)
        try:
            cmd = recognizer.recognize_google(audio, language=current_input_lang).lower().strip()
            print(f"ğŸ—£ï¸ Heard: {cmd}")
            return cmd
        except sr.UnknownValueError:
            attempts += 1
            print("ğŸ˜•", error_understand)
            if not suppress:
                speak(error_understand, lang=current_tts_lang)
                if attempts < 3:
                    speak(repeat_command.get(current_tts_lang, "Please repeat your command."), lang=current_tts_lang)
        except sr.RequestError:
            attempts += 1
            print("ğŸ”Œ", error_connection)
            if not suppress:
                speak(error_connection, lang=current_tts_lang)
                if attempts < 3:
                    speak(repeat_command.get(current_tts_lang, "Please repeat your command."), lang=current_tts_lang)
    return ""

def listen_for_chat():
    global recognizer
    attempts = 0
    # Localized reâ€‘prompt messages for chat.
    repeat_message = {
        "en": "Please repeat your message.",
        "ar": "ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ø§Ù„ØªÙƒ.",
        "fr": "Veuillez rÃ©pÃ©ter votre message."
    }
    while attempts < 3:
        with sr.Microphone() as source:
            print("ğŸ™ï¸ Listening for chat input...")
            recognizer.adjust_for_ambient_noise(source, duration=1)
            recognizer.pause_threshold = 0.8
            audio = recognizer.listen(source, phrase_time_limit=15)
        try:
            chat = recognizer.recognize_google(audio, language=current_input_lang).lower().strip()
            print(f"ğŸ—£ï¸ Heard (chat): {chat}")
            return chat
        except sr.UnknownValueError:
            attempts += 1
            print("ğŸ˜•", error_understand)
            speak(error_understand, lang=current_tts_lang)
            if attempts < 3:
                speak(repeat_message.get(current_tts_lang, "Please repeat your message."), lang=current_tts_lang)
        except sr.RequestError:
            attempts += 1
            print("ğŸ”Œ", error_connection)
            speak(error_connection, lang=current_tts_lang)
            if attempts < 3:
                speak(repeat_message.get(current_tts_lang, "Please repeat your message."), lang=current_tts_lang)
    return ""

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# FOLLOWâ€‘UP LOGIC (UPDATED)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def follow_up_query():
    """
    Allow multiple followâ€‘up questions strictly about the last photo.
    The same image is reâ€‘attached to every request so answers stay on topic.
    """
    global last_image_b64
    if not last_image_b64:
        return

    while True:
        followup_prompts = {
            "ar": "Ù‡Ù„ Ù„Ø¯ÙŠÙƒ Ø³Ø¤Ø§Ù„ Ù…ØªØ§Ø¨Ø¹Ø© Ø­ÙˆÙ„ Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ø©ØŸ Ø¥Ø°Ø§ Ù†Ø¹Ù… Ø§Ø·Ø±Ø­Ù‡ØŒ ÙˆØ¥Ù„Ø§ Ù‚Ù„ Ù„Ø§.",
            "fr": "Avezâ€‘vous une question de suivi concernant cette image ? Si non, dites Â« non Â». ",
            "en": "Do you have a followâ€‘up question about this image? If not, say no."
        }
        prompt = followup_prompts.get(current_tts_lang, followup_prompts["en"])
        speak(prompt, lang=current_tts_lang)

        query = listen_for_chat().lower().strip()
        if query == "" or query == " ":
            return

        no_tokens = {
            "ar": {"Ù„Ø§", "ÙƒÙ„Ø§"},
            "fr": {"non", "revenir"},
            "en": {"no", "nope", "back", "cancel", "Cancel"}
        }
        if query in no_tokens.get(current_tts_lang, {"no"}):
            return

        try:
            resp = openai.ChatCompletion.create(
                model="gpt-4-turbo",
                messages=[
                    {"role": "system", "content": chat_system_prompt},
                    {"role": "system", "content": "Base every answer strictly on the attached photo."},
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": query},
                            {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{last_image_b64}"}}
                        ],
                    },
                ],
                max_tokens=300,
            )
            answer = resp.choices[0].message.content
        except Exception as e:
            print("Error with OpenAI API in followâ€‘up query:", e)
            followup_error = {
                "en": "There was an error processing your followâ€‘up.",
                "ar": "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹.",
                "fr": "Une erreur est survenue lors du traitement de votre question de suivi."
            }
            speak(followup_error.get(current_tts_lang, "There was an error processing your followâ€‘up."), lang=current_tts_lang)
            return

        print("ğŸ§  ChatGPT Followâ€‘Up Response:", answer)
        speak(answer, lang=current_tts_lang)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# HELP / ABOUT
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def show_help():
    if current_tts_lang == "en":
        msg = "Available commands: capture, translate, read, moneycounter, chat, sleep, help, about, exit."
    elif current_tts_lang == "ar":
        msg = "Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©: Ø§Ù„ØªÙ‚Ø·ØŒ ØªØ±Ø¬Ù…ØŒ Ø§Ù‚Ø±Ø£ØŒ Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø§Ù„ØŒ Ø¯Ø±Ø¯Ø´Ø©ØŒ Ù†ÙˆÙ…ØŒ Ù…Ø³Ø§Ø¹Ø¯Ø©ØŒ Ø¹Ù† Ø§Ù„Ø¬Ù‡Ø§Ø²ØŒ Ø®Ø±ÙˆØ¬."
    else:
        msg = "Commandes disponibles : capturer, traduire, lire, compteur, discussion, sommeil, aide, Ã  propos, sortir."
    speak(msg, lang=current_tts_lang)

def show_about():
    msg = {
        "en": "I am Nour the smart glasses, I help people live.",
        "ar": "Ø£Ù†Ø§ Ù†ÙˆØ± Ø§Ù„Ù†Ø¸Ø§Ø±Ø§Øª Ø§Ù„Ø°ÙƒÙŠØ©ØŒ Ø£Ø³Ø§Ø¹Ø¯ Ø§Ù„Ù†Ø§Ø³ Ø¹Ù„Ù‰ Ø§Ù„Ø¹ÙŠØ´.",
        "fr": "Je suis Nour, les lunettes intelligentes, j'aide les gens Ã  vivre."
    }.get(current_tts_lang, "")
    speak(msg, lang=current_tts_lang)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# COMMAND TABLES
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def get_known_commands():
    if current_tts_lang == "en":
        return {
            "exit": exit_cmd,
            "capture": capture_cmd,
            "translate": translate_cmd,
            "read": read_cmd,
            "chat": chat_cmd,
            "money counter": moneycounter_cmd,
            "help": "help",
            "about": "about",
            "sleep": "sleep",
        }
    elif current_tts_lang == "ar":
        return {
            "exit": exit_cmd,
            "capture": capture_cmd,
            "translate": translate_cmd,
            "read": read_cmd,
            "chat": chat_cmd,
            "money counter": moneycounter_cmd,
            "help": "Ù…Ø³Ø§Ø¹Ø¯Ø©",
            "about": "Ø¹Ù† Ø§Ù„Ø¬Ù‡Ø§Ø²",
            "sleep": "Ù†ÙˆÙ…",
        }
    else:
        return {
            "exit": exit_cmd,
            "capture": capture_cmd,
            "translate": translate_cmd,
            "read": read_cmd,
            "chat": chat_cmd,
            "money counter": moneycounter_cmd,
            "help": "aide",
            "about": "Ã  propos",
            "sleep": "sommeil",
        }

# Moved out to module level.
def autocomplete_command(cmd: str) -> str:
    """
    Take a (possibly partial / slightly misspelled) spoken command and
    return the best full command + any trailing args, or "" if no input,
    or the cleaned original if nothing else matches.
    Enhanced: removes punctuation and uses a lower cutoff for fuzzy matching.
    """
    # 1) Normalize and remove punctuation
    import string
    translator = str.maketrans('', '', string.punctuation)
    cmd_clean = " ".join(cmd.lower().strip().translate(translator).split())
    if not cmd_clean:
        return ""

    # 2) Gather known commands
    known = list(get_known_commands().values())

    # 3) Exact match
    if cmd_clean in known:
        return cmd_clean

    # 4) Prefix match (longest known first, so we match the most specific)
    for full in sorted(known, key=len, reverse=True):
        if cmd_clean.startswith(full):
            rest = cmd_clean[len(full):].strip()
            return full + (f" {rest}" if rest else "")

    # 5) Fuzzy match for typos with lower cutoff of 0.5
    close = difflib.get_close_matches(cmd_clean, known, n=1, cutoff=0.5)
    if close:
        return close[0]

    # 6) Give back what we got (so downstream can handle it as â€œunknownâ€)
    return cmd_clean

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Helper function for precise command matching.
def command_matches(command, base_cmd):
    # Returns True if command equals base_cmd or starts with it followed by a space.
    return command == base_cmd or command.startswith(base_cmd + " ")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# LANGUAGE SELECTION (WITH FIXED ERRORS)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def select_language():
    global current_input_lang, current_tts_lang
    global exit_cmd, capture_cmd, translate_cmd, read_cmd, chat_cmd, moneycounter_cmd
    global prompt_capture, prompt_translate, prompt_read, prompt_moneycounter, chat_system_prompt
    global feedback_capture_start, feedback_capture_success, error_capture, error_connection, error_understand
    global entering_chat, exiting_chat, exiting_program, unknown_command

    # temporary Arabic prompt
    current_input_lang, current_tts_lang = "ar-SA", "ar"
    error_understand = "Ù„Ù… Ø£ÙÙ‡Ù… Ù…Ø§ Ù‚Ù„Øª. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰."
    error_connection = "Ø£ÙˆØ§Ø¬Ù‡ Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªØµØ§Ù„ Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª."
    speak("Ù‡Ù„ ØªØ±ÙŠØ¯ Ù„ØºØ© Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© Ø£Ù… Ø¹Ø±Ø¨ÙŠØ© Ø£Ù… ÙØ±Ù†Ø³ÙŠØ©ØŸ", lang="ar")
    ans = listen_for_command()

    # â€” ENGLISH â€”
    if "english" in ans or "Ø§Ù†Ø¬Ù„ÙŠØ²ÙŠ" in ans:
        current_input_lang, current_tts_lang = "en-US", "en"
        error_understand = "Sorry, I didn't catch that. Please try again."
        error_connection = "Connection issue. Please check your internet."
        exit_cmd, capture_cmd, translate_cmd, read_cmd = "exit", "capture", "translate", "read"
        chat_cmd, moneycounter_cmd = "chat", "money counter"
        prompt_capture = "What do you see in this image?"
        prompt_translate = "Translate any text in this image into English."
        prompt_read = "Read the text in this image aloud."
        prompt_moneycounter = "Count the money in this image."
        chat_system_prompt = (
            "You are a friendly and informative conversational assistant. Engage like a friend."
        )
        feedback_capture_start, feedback_capture_success = (
            "Capturing image now.",
            "Image captured successfully.",
        )
        error_capture = "Failed to capture image. Please check your camera."
        entering_chat, exiting_chat = (
            "Entering chitchat mode. Say 'exit' to leave.",
            "Exiting chitchat mode.",
        )
        exiting_program, unknown_command = (
            "Exiting program now. Goodbye!",
            "Unknown command. Say capture, read, translate, chat, moneycounter, help, about, or exit.",
        )
        speak("Language set to English.", lang=current_tts_lang)

    # â€” ARABIC â€”
    elif "Ø¹Ø±Ø¨ÙŠ" in ans or "arabic" in ans:
        current_input_lang, current_tts_lang = "ar-SA", "ar"
        error_understand = "Ù„Ù… Ø£ÙÙ‡Ù… Ù…Ø§ Ù‚Ù„Øª. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰."
        error_connection = "Ø£ÙˆØ§Ø¬Ù‡ Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªØµØ§Ù„ Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª."
        exit_cmd, capture_cmd, translate_cmd, read_cmd = "Ø®Ø±ÙˆØ¬", "Ø§Ù„ØªÙ‚Ø·", "ØªØ±Ø¬Ù…", "Ø§Ù‚Ø±Ø£"
        chat_cmd, moneycounter_cmd = "Ø¯Ø±Ø¯Ø´Ø©", "Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø§Ù„"
        prompt_capture = "Ù…Ø§Ø°Ø§ ØªØ±Ù‰ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ø©ØŸ"
        prompt_translate = "ØªØ±Ø¬Ù… Ø£ÙŠ Ù†Øµ Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©."
        prompt_read = "Ø§Ù‚Ø±Ø£ Ø§Ù„Ù†Øµ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ø©."
        prompt_moneycounter = "Ø¹Ø¯ Ø§Ù„Ù†Ù‚ÙˆØ¯ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ø©."
        chat_system_prompt = "Ø£Ù†Øª Ù…Ø³Ø§Ø¹Ø¯ ÙˆØ¯ÙˆØ¯ ÙˆÙ…ÙÙŠØ¯. ØªØ­Ø¯Ø« Ù…Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø£Ø³Ù„ÙˆØ¨ Ù…Ø±ÙŠØ­."
        feedback_capture_start, feedback_capture_success = (
            "Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø¢Ù†.",
            "ØªÙ… Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­.",
        )
        error_capture = "ÙØ´Ù„ Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ØµÙˆØ±Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§."
        entering_chat, exiting_chat = (
            "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¥Ù„Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©. Ù‚Ù„ 'Ø®Ø±ÙˆØ¬' Ù„Ù„Ø®Ø±ÙˆØ¬.",
            "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©.",
        )
        exiting_program, unknown_command = (
            "Ø¬Ø§Ø±Ù Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬. Ù…Ø¹ Ø§Ù„Ø³Ù„Ø§Ù…Ø©!",
            "Ø£Ù…Ø± ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ. Ù‚Ù„ Ø§Ù„ØªÙ‚Ø·ØŒ Ø§Ù‚Ø±Ø£ØŒ ØªØ±Ø¬Ù…ØŒ Ø¯Ø±Ø¯Ø´Ø©ØŒ Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø§Ù„ØŒ Ù…Ø³Ø§Ø¹Ø¯Ø©ØŒ Ø¹Ù† Ø§Ù„Ø¬Ù‡Ø§Ø²ØŒ Ø£Ùˆ Ø®Ø±ÙˆØ¬.",
        )
        speak("ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.", lang=current_tts_lang)

    # â€” FRENCH â€”
    elif "french" in ans or "franÃ§ais" in ans or "ÙØ±Ù†Ø³ÙŠ" in ans:
        current_input_lang, current_tts_lang = "fr-FR", "fr"
        error_understand = "DÃ©solÃ©, je n'ai pas compris. Veuillez rÃ©essayer."
        error_connection = "ProblÃ¨me de connexion. Veuillez vÃ©rifier votre Internet."
        exit_cmd, capture_cmd, translate_cmd, read_cmd = "sortir", "capturer", "traduire", "lire"
        chat_cmd, moneycounter_cmd = "discussion", "compteur"
        prompt_capture = "Que voyezâ€‘vous dans cette image ?"
        prompt_translate = "Traduisez le texte de cette image en franÃ§ais."
        prompt_read = "Lisez le texte de cette image Ã  haute voix."
        prompt_moneycounter = "Comptez l'argent dans cette image."
        chat_system_prompt = "Vous Ãªtes un assistant amical et informatif."
        feedback_capture_start, feedback_capture_success = (
            "Capture de l'image en cours.",
            "Image capturÃ©e avec succÃ¨s.",
        )
        error_capture = "Ã‰chec de la capture. VÃ©rifiez la camÃ©ra."
        entering_chat, exiting_chat = (
            "EntrÃ©e en mode discussion. Dites 'sortir' pour quitter.",
            "Sortie du mode discussion.",
        )
        exiting_program, unknown_command = (
            "Fermeture du programme. Au revoir !",
            "Commande inconnue. Dites capturer, lire, traduire, discussion, compteur, aide, Ã  propos ou sortir.",
        )
        speak("Langue dÃ©finie sur le franÃ§ais.", lang=current_tts_lang)

    # â€” DEFAULT ENGLISH â€”
    else:
        current_input_lang, current_tts_lang = "en-US", "en"
        error_understand = "Sorry, I didn't catch that. Please try again."
        error_connection = "Connection issue. Please check your internet."
        exit_cmd, capture_cmd, translate_cmd, read_cmd = "exit", "capture", "translate", "read"
        chat_cmd, moneycounter_cmd = "chat", "money counter"
        prompt_capture = "What do you see in this image?"
        prompt_translate = "Translate any text in this image into English."
        prompt_read = "Read the text in this image aloud."
        prompt_moneycounter = "Count the money in this image."
        chat_system_prompt = (
            "You are a friendly and informative conversational assistant. Engage like a friend."
        )
        feedback_capture_start, feedback_capture_success = (
            "Capturing image now.",
            "Image captured successfully.",
        )
        error_capture = "Failed to capture image. Please check your camera."
        entering_chat, exiting_chat = (
            "Entering chitchat mode. Say 'exit' to leave.",
            "Exiting chitchat mode.",
        )
        exiting_program, unknown_command = (
            "Exiting program now. Goodbye!",
            "Unknown command. Say capture, read, translate, chat, moneycounter, help, about, or exit.",
        )
        speak("Language not recognized. Defaulting to English.", lang=current_tts_lang)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# INITIALISE LANGUAGE
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
select_language()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# IMAGE UTILITIES
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def image_to_base64(path):
    with open(path, "rb") as f:
        return base64.b64encode(f.read()).decode("utf-8")

def capture_image():
    global last_image_b64
    speak(feedback_capture_start, lang=current_tts_lang)
    print("ğŸ“· Capturing image...")
    cam = cv2.VideoCapture(0)
    ret, frame = cam.read()
    img_path = "captured.jpg"
    if ret:
        cv2.imwrite(img_path, frame)
        last_image_b64 = image_to_base64(img_path)
        print("âœ… Image saved.")
        speak(feedback_capture_success, lang=current_tts_lang)
    else:
        print("âŒ", error_capture)
        speak(error_capture, lang=current_tts_lang)
        img_path, last_image_b64 = None, None
    cam.release()
    return img_path

def send_image_to_chatgpt(image_path, prompt):
    speak("Sending image to assistant for " + prompt, lang=current_tts_lang)
    print(f"ğŸ¤– Sending image to ChatGPT with prompt: {prompt}")
    b64 = image_to_base64(image_path)
    try:
        resp = openai.ChatCompletion.create(
            model="gpt-4-turbo",
            messages=[
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt},
                        {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{b64}"}}
                    ],
                }
            ],
            max_tokens=500,
        )
        result = resp.choices[0].message.content
        print("ğŸ§  ChatGPT Response:", result)
        return result
    except Exception as e:
        print("Error with OpenAI API in send_image_to_chatgpt:", e)
        img_error = {
            "en": "There was an error processing your image request.",
            "ar": "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨ Ø§Ù„ØµÙˆØ±Ø©.",
            "fr": "Une erreur est survenue lors du traitement de votre demande d'image."
        }
        speak(img_error.get(current_tts_lang, "There was an error processing your image request."), lang=current_tts_lang)
        return "There was an error processing your image request."

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# MAIN LOOP
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
while True:
    command = autocomplete_command(listen_for_command())
    if not command:
        continue

    # Language change
    if any(kw in command for kw in ["change language", "ØºÙŠØ± Ø§Ù„Ù„ØºØ©", "changer la langue"]):
        select_language()
        continue

    # Help / About
    if command_matches(command, "help") or command_matches(command, "Ù…Ø³Ø§Ø¹Ø¯Ø©") or command_matches(command, "aide"):
        show_help()
        continue
    if command_matches(command, "about") or command_matches(command, "Ø¹Ù† Ø§Ù„Ø¬Ù‡Ø§Ø²") or command_matches(command, "Ã  propos") or command_matches(command, "a propos"):
        show_about()
        continue

    # Sleep mode: when the command "sleep" (or localized equivalent) is given,
    # the program immediately enters a silent mode where it will ignore all input until a wake command is heard.
    if command_matches(command, "sleep") or command_matches(command, "Ù†ÙˆÙ…") or command_matches(command, "sommeil"):
        # Do not speak immediately; while sleeping, we call listen_for_command(suppress=True) to avoid any speech.
        while True:
            wake = listen_for_command(suppress=True).lower().strip()
            if wake in ["wake", "wake up", "Ø§Ø³ØªÙŠÙ‚Ø¸", "rÃ©veille-toi"]:
                resume_msg = {
                    "en": "Resuming operation.",
                    "ar": "Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ø¹Ù…Ù„.",
                    "fr": "Reprise de l'activitÃ©."
                }
                speak(resume_msg.get(current_tts_lang, "Resuming operation."), lang=current_tts_lang)
                break
        continue

    # Exit
    if command_matches(command, exit_cmd):
        speak(exiting_program, lang=current_tts_lang)
        print("ğŸ‘‹", exiting_program)
        break

    # Captureâ€‘based commands
    if command_matches(command, capture_cmd):
        path = capture_image()
        if path:
            speak(send_image_to_chatgpt(path, prompt_capture), lang=current_tts_lang)
            follow_up_query()
        continue
    if command_matches(command, translate_cmd):
        path = capture_image()
        if path:
            speak(send_image_to_chatgpt(path, prompt_translate), lang=current_tts_lang)
            follow_up_query()
        continue
    if command_matches(command, read_cmd):
        path = capture_image()
        if path:
            speak(send_image_to_chatgpt(path, prompt_read), lang=current_tts_lang)
            follow_up_query()
        continue
    if command_matches(command, moneycounter_cmd):
        path = capture_image()
        if path:
            speak(send_image_to_chatgpt(path, prompt_moneycounter), lang=current_tts_lang)
            follow_up_query()
        continue

    # Chat mode
    if command_matches(command, chat_cmd) or command_matches(command, "Ø¯Ø±Ø¯Ø´Ø©") or command_matches(command, "discussion"):
        speak(entering_chat, lang=current_tts_lang)
        print("ğŸ’¬", entering_chat)
        while True:
            chat_in = listen_for_chat()
            if command_matches(chat_in, exit_cmd):
                speak(exiting_chat, lang=current_tts_lang)
                print("ğŸ’¬", exiting_chat)
                break
            try:
                resp = openai.ChatCompletion.create(
                    model="gpt-3.5-turbo",
                    messages=[
                        {"role": "system", "content": chat_system_prompt},
                        {"role": "user", "content": chat_in},
                    ],
                    max_tokens=300,
                )
                reply = resp.choices[0].message.content
            except Exception as e:
                print("Error with OpenAI API in chat mode:", e)
                chat_error = {
                    "en": "There was an error processing your chat request.",
                    "ar": "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©.",
                    "fr": "Une erreur est survenue lors du traitement de votre demande de chat."
                }
                speak(chat_error.get(current_tts_lang, "There was an error processing your chat request."), lang=current_tts_lang)
                continue
            print("ğŸ§  ChatGPT Chitchat Response:", reply)
            speak(reply, lang=current_tts_lang)
        continue

    # Unknown command
    print(unknown_command)
    speak(unknown_command, lang=current_tts_lang)
